import logging
import os
from typing import Any, Dict

from langchain_core.messages import AIMessage
from openai import AsyncOpenAI

from ..classes import ResearchState
from ..utils.references import format_references_section

logger = logging.getLogger(__name__)

class Editor:
    """Compile les synth√®ses de chaque section en un rapport final coh√©rent."""
    
    def __init__(self) -> None:
        self.openai_key = os.getenv("OPENAI_API_KEY")
        if not self.openai_key:
            raise ValueError("La variable d‚Äôenvironnement OPENAI_API_KEY n‚Äôest pas d√©finie")
        
        # Configuration d‚ÄôOpenAI
        self.openai_client = AsyncOpenAI(api_key=self.openai_key)
        
        # Initialisation du dictionnaire de contexte utilis√© dans les m√©thodes
        self.context = {
            "company": "Entreprise inconnue",
            "industry": "Secteur inconnu",
            "hq_location": "Inconnue"
        }

    async def compile_briefings(self, state: ResearchState) -> ResearchState:
        """Compile les diff√©rentes synth√®ses en un rapport final."""
        company = state.get('company', 'Entreprise inconnue')
        
        # Mettre √† jour le contexte avec les valeurs de l‚Äô√©tat
        self.context = {
            "company": company,
            "industry": state.get('industry', 'Secteur inconnu'),
            "hq_location": state.get('hq_location', 'Inconnue')
        }
        
        # Envoi du statut initial de compilation
        if websocket_manager := state.get('websocket_manager'):
            if job_id := state.get('job_id'):
                await websocket_manager.send_status_update(
                    job_id=job_id,
                    status="processing",
                    message=f"D√©marrage de la compilation du rapport pour {company}",
                    result={
                        "step": "√âditeur",
                        "substep": "initialisation"
                    }
                )

        context = {
            "company": company,
            "industry": state.get('industry', 'Secteur inconnu'),
            "hq_location": state.get('hq_location', 'Inconnue')
        }
        
        msg = [f"üìë Compilation du rapport final pour {company}..."]
        
        # R√©cup√©ration des synth√®ses individuelles √† partir de l‚Äô√©tat
        briefing_keys = {
            'company': 'company_briefing',
            'industry': 'industry_briefing',
            'financial': 'financial_briefing',
            'news': 'news_briefing'
        }

        # Envoi du statut de collecte des synth√®ses
        if websocket_manager := state.get('websocket_manager'):
            if job_id := state.get('job_id'):
                await websocket_manager.send_status_update(
                    job_id=job_id,
                    status="processing",
                    message="Collecte des synth√®ses de sections",
                    result={
                        "step": "√âditeur",
                        "substep": "collecte_synth√®ses"
                    }
                )

        individual_briefings = {}
        for category, key in briefing_keys.items():
            if content := state.get(key):
                individual_briefings[category] = content
                msg.append(f"Synth√®se {category} trouv√©e ({len(content)} caract√®res)")
            else:
                msg.append(f"Aucune synth√®se {category} disponible")
                logger.error(f"Cl√© d‚Äô√©tat manquante : {key}")
        
        if not individual_briefings:
            msg.append("\n‚ö†Ô∏è Aucune section de synth√®se disponible pour la compilation")
            logger.error("Aucune synth√®se trouv√©e dans l‚Äô√©tat")
        else:
            try:
                compiled_report = await self.edit_report(state, individual_briefings, context)
                if not compiled_report or not compiled_report.strip():
                    logger.error("Le rapport compil√© est vide !")
                else:
                    logger.info(f"Rapport compil√© avec succ√®s ({len(compiled_report)} caract√®res)")
            except Exception as e:
                logger.error(f"Erreur lors de la compilation du rapport : {e}")
        state.setdefault('messages', []).append(AIMessage(content="\n".join(msg)))
        return state
    
    async def edit_report(self, state: ResearchState, briefings: Dict[str, str], context: Dict[str, Any]) -> str:
        """Assemble les sections en un rapport final et met √† jour l‚Äô√©tat."""
        try:
            company = self.context["company"]
            
            # √âtape 1 : Compilation initiale
            if websocket_manager := state.get('websocket_manager'):
                if job_id := state.get('job_id'):
                    await websocket_manager.send_status_update(
                        job_id=job_id,
                        status="processing",
                        message="Compilation du rapport de recherche initial",
                        result={
                            "step": "√âditeur",
                            "substep": "compilation"
                        }
                    )

            edited_report = await self.compile_content(state, briefings, company)
            if not edited_report:
                logger.error("√âchec de la compilation initiale")
                return ""

            # √âtape 2 : Nettoyage et d√©duplication
            if websocket_manager := state.get('websocket_manager'):
                if job_id := state.get('job_id'):
                    await websocket_manager.send_status_update(
                        job_id=job_id,
                        status="processing",
                        message="Nettoyage et organisation du rapport",
                        result={
                            "step": "√âditeur",
                            "substep": "nettoyage"
                        }
                    )

            # √âtape 3 : Mise en forme du rapport final
            if websocket_manager := state.get('websocket_manager'):
                if job_id := state.get('job_id'):
                    await websocket_manager.send_status_update(
                        job_id=job_id,
                        status="processing",
                        message="Mise en forme du rapport final",
                        result={
                            "step": "√âditeur",
                            "substep": "mise_en_forme"
                        }
                    )
            final_report = await self.content_sweep(state, edited_report, company)
            
            final_report = final_report or ""
            
            logger.info(f"Rapport final compil√© ({len(final_report)} caract√®res)")
            if not final_report.strip():
                logger.error("Le rapport final est vide !")
                return ""
            
            logger.info("Aper√ßu du rapport final :")
            logger.info(final_report[:500])
            
            # Mise √† jour de l‚Äô√©tat avec le rapport final
            state['report'] = final_report
            state['status'] = "editor_complete"
            if 'editor' not in state or not isinstance(state['editor'], dict):
                state['editor'] = {}
            state['editor']['report'] = final_report
            logger.info(f"Taille du rapport dans l‚Äô√©tat : {len(state.get('report', ''))}")
            
            if websocket_manager := state.get('websocket_manager'):
                if job_id := state.get('job_id'):
                    await websocket_manager.send_status_update(
                        job_id=job_id,
                        status="editor_complete",
                        message="Rapport de recherche termin√©",
                        result={
                            "step": "√âditeur",
                            "report": final_report,
                            "company": company,
                            "is_final": True,
                            "status": "termin√©"
                        }
                    )
            
            return final_report
        except Exception as e:
            logger.error(f"Erreur dans edit_report : {e}")
            return ""
    
    async def compile_content(self, state: ResearchState, briefings: Dict[str, str], company: str) -> str:
        """Compilation initiale des sections de recherche."""
        combined_content = "\n\n".join(content for content in briefings.values())
        
        references = state.get('references', [])
        reference_text = ""
        if references:
            logger.info(f"{len(references)} r√©f√©rences trouv√©es √† ajouter pendant la compilation")
            
            reference_info = state.get('reference_info', {})
            reference_titles = state.get('reference_titles', {})
            
            logger.info(f"Informations sur les r√©f√©rences : {reference_info}")
            logger.info(f"Titres des r√©f√©rences : {reference_titles}")
            
            reference_text = format_references_section(references, reference_info, reference_titles)
            logger.info(f"{len(references)} r√©f√©rences ajout√©es pendant la compilation")
        
        company = self.context["company"]
        industry = self.context["industry"]
        hq_location = self.context["hq_location"]
        
        prompt = f"""Vous compilez un rapport de recherche complet sur {company}.

Synth√®ses compil√©es :
{combined_content}

R√©digez un rapport complet et structur√© sur {company}, une entreprise du secteur {industry} dont le si√®ge est √† {hq_location}, qui :
1. Int√®gre les informations de toutes les sections sans r√©p√©tition
2. Pr√©serve les d√©tails importants de chaque section
3. Organise logiquement le contenu et supprime les transitions inutiles
4. Utilise des titres de section clairs

Structure obligatoire :
# Rapport de recherche sur {company}

## Pr√©sentation de l‚Äôentreprise
[Contenu de l‚Äôentreprise avec ### sous-sections]

## Pr√©sentation du secteur
[Contenu du secteur avec ### sous-sections]

## Pr√©sentation financi√®re
[Contenu financier avec ### sous-sections]

## Actualit√©s
[Contenu des actualit√©s avec ### sous-sections]

Retournez le rapport en **markdown clair**, sans explications ni commentaires."""
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4.1",
                messages=[
                    {
                        "role": "system",
                        "content": "Vous √™tes un r√©dacteur expert charg√© de compiler des synth√®ses de recherche en rapports d‚Äôentreprise complets."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0,
                stream=False
            )
            initial_report = response.choices[0].message.content.strip()
            
            if reference_text:
                initial_report = f"{initial_report}\n\n{reference_text}"
            
            return initial_report
        except Exception as e:
            logger.error(f"Erreur lors de la compilation initiale : {e}")
            return (combined_content or "").strip()
        
    async def content_sweep(self, state: ResearchState, content: str, company: str) -> str:
        """Nettoie le contenu pour supprimer les redondances et incoh√©rences."""
        company = self.context["company"]
        industry = self.context["industry"]
        hq_location = self.context["hq_location"]
        
        prompt = f"""Vous √™tes un √©diteur de synth√®ses expert. Vous devez corriger le rapport suivant sur {company}.

Rapport actuel :
{content}

T√¢ches :
1. Supprimer les informations redondantes
2. Supprimer les √©l√©ments non pertinents pour {company}, entreprise du secteur {industry} bas√©e √† {hq_location}
3. Supprimer les sections vides
4. Supprimer tout m√©ta-commentaire (‚ÄúVoici les actualit√©s‚Ä¶‚Äù)

Structure obligatoire :
## Pr√©sentation de l‚Äôentreprise
## Pr√©sentation du secteur
## Pr√©sentation financi√®re
## Actualit√©s
## R√©f√©rences

R√®gles :
- Le document doit commencer par : # Rapport de recherche sur {company}
- N‚Äôutiliser **que** ces en-t√™tes ## dans cet ordre exact
- Pas d‚Äôautres en-t√™tes ## autoris√©s
- Utiliser ### pour les sous-sections
- Les actualit√©s doivent utiliser uniquement des puces (*)
- Aucun bloc de code, ni ligne vide multiple
- Ne pas modifier la section R√©f√©rences

Retournez le rapport nettoy√© en markdown parfait, sans explications."""
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4.1-mini", 
                messages=[
                    {
                        "role": "system",
                        "content": "Vous √™tes un formateur markdown expert garantissant la coh√©rence du document."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0,
                stream=True
            )
            
            accumulated_text = ""
            buffer = ""
            
            async for chunk in response:
                if chunk.choices[0].finish_reason == "stop":
                    websocket_manager = state.get('websocket_manager')
                    if websocket_manager and buffer:
                        job_id = state.get('job_id')
                        if job_id:
                            await websocket_manager.send_status_update(
                                job_id=job_id,
                                status="report_chunk",
                                message="Mise en forme du rapport final",
                                result={
                                    "chunk": buffer,
                                    "step": "√âditeur"
                                }
                            )
                    break
                    
                chunk_text = chunk.choices[0].delta.content
                if chunk_text:
                    accumulated_text += chunk_text
                    buffer += chunk_text
                    
                    if any(char in buffer for char in ['.', '!', '?', '\n']) and len(buffer) > 10:
                        if websocket_manager := state.get('websocket_manager'):
                            if job_id := state.get('job_id'):
                                await websocket_manager.send_status_update(
                                    job_id=job_id,
                                    status="report_chunk",
                                    message="Mise en forme du rapport final",
                                    result={
                                        "chunk": buffer,
                                        "step": "√âditeur"
                                    }
                                )
                        buffer = ""
            
            return (accumulated_text or "").strip()
        except Exception as e:
            logger.error(f"Erreur de mise en forme : {e}")
            return (content or "").strip()

    async def run(self, state: ResearchState) -> ResearchState:
        state = await self.compile_briefings(state)
        # S‚Äôassurer que la sortie de l‚Äô√©diteur est stock√©e au niveau sup√©rieur et dans ‚Äúeditor‚Äù
        if 'report' in state:
            if 'editor' not in state or not isinstance(state['editor'], dict):
                state['editor'] = {}
            state['editor']['report'] = state['report']
        return state
